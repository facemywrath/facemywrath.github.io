<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Archmage — Spells & Essences</title>
<style>
  :root{
    --bg:#0f1117; --ink:#e7ecff; --muted:#a6b0d1;
    --box:#141a2b; --box2:#101629; --br:rgba(255,255,255,.08);
    --mana:#7aa2ff; --ess:#b7ffd9; --wiz:#caa7ff; 
    --fire:#ff9a8b; --ice:#9ad7ff; --earth:#c9d48e; --wind:#c8fff2;
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1200px 780px at 12% -10%, #1c2452 0%, var(--bg) 60%);color:var(--ink);font:14px/1.55 system-ui,Segoe UI,Inter,Roboto,Arial}
  header{position:sticky;top:0;z-index:10;padding:10px 12px;border-bottom:1px solid var(--br);background:linear-gradient(180deg,#0e1324,transparent);backdrop-filter:blur(6px)}
  .row{display:flex;justify-content:space-between;align-items:center;gap:8px}
  .chips{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px}
  .chip{background:var(--box2);border:1px solid var(--br);padding:6px 10px;border-radius:10px}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  main.grid{display:grid;gap:12px;padding:12px;grid-template-columns:repeat(auto-fit,minmax(290px,1fr))}
  .mod{background:linear-gradient(180deg,var(--box),var(--box2));border:1px solid var(--br);border-radius:14px;padding:12px}
  .mod h3{margin:0 0 8px 0;font-size:15px;letter-spacing:.2px}
  .sub{color:var(--muted);font-size:12px}
  .hr{height:1px;background:var(--br);margin:10px 0}
  .btn{cursor:pointer;border:1px solid var(--br);background:linear-gradient(180deg,#243057,#1a1f3b);color:var(--ink);padding:8px 10px;border-radius:10px;width:100%}
  .btn:hover{filter:brightness(1.05)}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  .btn.good{background:linear-gradient(180deg,#294034,#1b2b21);border-color:#2b6640}
  .btn.warn{background:linear-gradient(180deg,#4a3a19,#2a2413);border-color:#6a561a}
  .line{display:flex;justify-content:space-between;gap:10px;align-items:center;margin:6px 0}
  .badge{font-size:11px;padding:2px 6px;border-radius:999px;border:1px solid var(--br);background:rgba(255,255,255,.05)}
  .tiny{font-size:11px;color:var(--muted)}
  .pill{display:inline-flex;gap:8px;align-items:center;border-radius:999px;padding:4px 10px;background:rgba(255,255,255,.05);border:1px solid var(--br)}
  .ess-list{display:grid;gap:8px;grid-template-columns:1fr}
  .btnrow{display:grid;grid-template-columns:1fr minmax(90px,110px);gap:8px}
  .deadbar{background:linear-gradient(180deg,#3d1420,#1c0d12);border:1px solid #5a1f31;border-radius:12px;padding:10px;margin-bottom:12px}
</style>
</head>
<body>
<header>
  <div class="row">
    <div>
      <div style="font-weight:700">Archmage — Spells & Essences</div>
      <div class="sub">Aging & rebirth enabled • Spells store their own functions • Knowledge persists between lives</div>
    </div>
    <div class="chip mono">FPS <span id="fps">—</span></div>
  </div>
  <div class="chips">
    <div class="chip">Age: <b id="ageYears">0.0</b>/<b id="lifeYears">75</b> yrs</div>
    <div class="chip">Knowledge ×<b id="knowledgeMult">1.00</b></div>
    <div class="chip">Global ×<b id="globalMult">1.00</b></div>
    <div class="chip">Infusions: <b id="infusions">0</b></div>
    <div class="chip" id="saveMsg">Autosaving…</div>
  </div>
</header>

<main id="grid" class="grid"></main>

<script>
/* ===== constants ===== */
const SAVE_KEY = "archmage_spells_ess_v4";

/* ===== tiny big number ===== */
class Dec{
  constructor(m=0,e=0){this.m=m;this.e=e;this._n();}
  static from(x){if(x instanceof Dec)return x.clone();if(x===0)return new Dec(0,0);const e=Math.floor(Math.log10(Math.abs(x)));return new Dec(x/10**e,e);}
  clone(){return new Dec(this.m,this.e)}
  _n(){if(!isFinite(this.m)||this.m===0){this.m=0;this.e=0;return}while(Math.abs(this.m)>=10){this.m/=10;this.e++}while(Math.abs(this.m)<1){this.m*=10;this.e--}}
  add(b){b=Dec.from(b);if(this.m===0)return b.clone();if(b.m===0)return this.clone();let a=this.clone();if(a.e<b.e){const t=a;a=b;b=t}const d=a.e-b.e;if(d>15)return a;a.m+=b.m/10**d;a._n();return a}
  sub(b){return this.add(Dec.from(b).mul(-1))}
  mul(b){b=Dec.from(b);if(this.m===0||b.m===0)return new Dec(0,0);return new Dec(this.m*b.m,this.e+b.e)}
  div(b){b=Dec.from(b);if(b.m===0)return new Dec(Infinity,0);if(this.m===0)return new Dec(0,0);return new Dec(this.m/b.m,this.e-b.e)}
  pow(n){if(this.m===0)return new Dec(0,0);if(n===0)return new Dec(1,0);const L=this.e+Math.log10(this.m);const P=L*n;const e=Math.floor(P);const m=10**(P-e);return new Dec(m,e)}
  gte(b){return this.cmp(b)>=0}
  cmp(b){b=Dec.from(b);if(this.m===0&&b.m===0)return 0;if(this.e!==b.e)return this.e>b.e?1:-1;if(this.m!==b.m)return this.m>b.m?1:-1;return 0}
  toString(){if(!isFinite(this.m))return"∞";if(this.m===0)return"0";if(this.e<6&&this.e>-4)return (this.m*10**this.e).toFixed(Math.max(0,2-Math.max(this.e,0)));return this.m.toFixed(3)+"e"+this.e}
  toJSON(){return {m:this.m,e:this.e}} static fromJSON(o){return new Dec(o.m,o.e)}
}
const D=x=>Dec.from(x), fmt=d=>Dec.from(d).toString();
const num = d => (d instanceof Dec) ? d.m * 10 ** d.e : Number(d||0); // approximate numeric

/* ===== design knobs ===== */
const CFG = {
  tick: 20, autosave: 10,
  essenceMasteryPerCast: 1,
  essenceMasteryBonusPerLevel: 0.05, // +5% essence per mastery level per element
  yearsPerSecond: 75/1200, // 75 yrs over 1200s => 0.0625 yr/s; lifespan extends real-time proportionally
};

/* ===== spells (each has its own fn(state, k)) ===== */
const SPELLS = [
  // Mana generator spells
  { key:"light",   name:"Cast Light", unlockCost:D(0), baseCost:D(1),   growth:1.01,  ratio:10,
    fn:(S,k)=>{ S.mana.baseMPS += 0.1 * k; } },
  { key:"presti",  name:"Cast Prestidigitation", unlockCost:D(25), baseCost:D(24), growth:1.015, ratio:12,
    fn:(S,k)=>{ S.mana.baseMPS += 2 * k; } },
  { key:"firebolt", name:"Cast Firebolt", unlockCost:D(180), baseCost:D(420), growth:1.02, ratio:14,
    fn:(S,k)=>{ S.mana.baseMPS += 30 * k; } },
  { key:"spark",   name:"Cast Spark", unlockCost:D(4200), baseCost:D(960), growth:1.025, ratio:16,
    fn:(S,k)=>{ S.mana.baseMPS += 100 * k; } },
  { key:"Frostbite", name:"Cast Frostbite", unlockCost:D(16000), baseCost:D(3160), growth:1.03, ratio:18,
    fn:(S,k)=>{ S.mana.baseMPS += 300 * k; } },
  { key:"ashield", name:"Cast Arcane Shield", unlockCost:D(75000), baseCost:D(12000), growth:1.035, ratio:20,
    fn:(S,k)=>{ S.mana.baseMPS += 1200 * k; } },
  { key:"illusion",name:"Cast Illusionary Form", unlockCost:D(420000), baseCost:D(50200), growth:1.04, ratio:24,
    fn:(S,k)=>{ S.mana.baseMPS += 5000 * k; } },
  { key:"gust",    name:"Cast Gust", unlockCost:D(4800000), baseCost:D(204400), growth:1.045, ratio:28,
    fn:(S,k)=>{ S.mana.baseMPS += 40000 * k; } },
  { key:"lift",    name:"Cast Lift", unlockCost:D(20000000), baseCost:D(1900400), growth:1.05, ratio:32,
    fn:(S,k)=>{ S.mana.baseMPS += 320000 * k; } },

  // Essence conjurations
  { key:"ce_earth", name:"Conjure Earth Essence", unlockCost:D(98000000),   baseCost:D(22160000), growth:1.20, conjures:true, elem:"earth",
    fn:(S,k)=>{ for(let i=0;i<k;i++){ giveEssence(S,"earth"); } } },
  { key:"ce_ice",   name:"Conjure Ice Essence",   unlockCost:D(2660000000), baseCost:D(900000000), growth:1.20, conjures:true, elem:"ice",
    fn:(S,k)=>{ for(let i=0;i<k;i++){ giveEssence(S,"ice"); } } },
  { key:"ce_fire",  name:"Conjure Fire Essence",  unlockCost:D(74600000000), baseCost:D(107250000000), growth:1.20, conjures:true, elem:"fire",
    fn:(S,k)=>{ for(let i=0;i<k;i++){ giveEssence(S,"fire"); } } },
  { key:"ce_wind",  name:"Conjure Wind Essence",  unlockCost:D(800000000000), baseCost:D(3400000000000), growth:1.20, conjures:true, elem:"wind",
    fn:(S,k)=>{ for(let i=0;i<k;i++){ giveEssence(S,"wind"); } } },
];

/* ===== state ===== */
function defaultState(){
  return {
    v:4,
    meta:{
      globalMult:1,
      knowledgeMult:1,
      last:Date.now(),
      manaPerCastBonus:1,
      essenceEffBase:null,
      rebirths:0,
      ageYears:0,
      lifespanYears:75,
      dead:false,
    },
    mana:{
      amount:D(0), baseMPS:0.15, perSec:D(0),
      spellIdx:0,
      casts: SPELLS.map(()=>0),
      unlocked: SPELLS.map((s,i)=> i===0),
    },
    ess:{
      unlocked:false,
      elements:{fire:0, ice:0, earth:0, wind:0},
      effLevel:0,
      infusions:{ fire:0, ice:0, earth:0, wind:0 },
      mastery:{ fire:0, ice:0, earth:0, wind:0 },
    }
  };
}
let G = defaultState();

/* ===== helpers ===== */
function currentSpell(){ return SPELLS[G.mana.spellIdx]; }
function layerMult(){
  const inf = G.ess.infusions;
  const manaMultFromInf = Math.pow(2, (inf.fire||0)+(inf.ice||0)+(inf.earth||0)+(inf.wind||0));
  return G.meta.globalMult * G.meta.knowledgeMult * manaMultFromInf;
}
function manaPerSec(){ return D(G.mana.baseMPS * layerMult()); }
function nextCastCost(spellIdx){
  const s = SPELLS[spellIdx];
  const n = G.mana.casts[spellIdx] || 0;
  return D(s.baseCost).mul(D(s.growth).pow(n));
}
function canAffordMana(x){ return G.mana.amount.gte(x); }
function spendMana(x){ G.mana.amount = G.mana.amount.sub(x); }

/* ===== essence math ===== */
function essenceEffTotal(){
  const lvl = G.ess.effLevel;
  if (lvl <= 0) return 1;
  return (10 * (lvl - 1) + 6) / (3 * lvl);
}
// base cost for eff from first essence unlock
function getEssenceRefCost(){
  const i = SPELLS.findIndex(s => s.conjures);
  return SPELLS[i].unlockCost;
}
function essenceEffCost(lvlOffset=0){
  if (G.meta.essenceEffBase == null) {
    const ref = getEssenceRefCost();
    const refNum = Math.max(100, 0.5 * num(ref));
    G.meta.essenceEffBase = refNum;
  }
  const lvl = G.ess.effLevel + lvlOffset;
  const growth = 3;
  return D(G.meta.essenceEffBase * Math.pow(growth, lvl));
}
// per-element mastery scaling
function essenceYield(elem){
  const eff = essenceEffTotal();
  const m = G.ess.mastery[elem] || 0;
  const scale = 1 + m * CFG.essenceMasteryBonusPerLevel;
  return eff * scale;
}
// integer cost for infusions (rounded up)
function infusionCost(elem, offset=0){
  const lvl = (G.ess.infusions[elem] || 0) + offset;
  return Math.max(1, Math.ceil(5 * Math.pow(lvl, 1.45)));
}

/* ===== Max calculators ===== */
function maxAffordableCasts(spellIdx){
  const s = SPELLS[spellIdx];
  const g = s.growth;
  const base = num(s.baseCost);
  const n = G.mana.casts[spellIdx] || 0;
  const have = num(G.mana.amount);
  if (have <= 0) return 0;
  if (g === 1) {
    return Math.floor(have / (base * Math.pow(g, n)));
  }
  const a0 = base * Math.pow(g, n);
  const k = Math.floor(Math.log( (have*(g-1))/a0 + 1 ) / Math.log(g));
  return Math.max(0, k);
}
function totalCostGeometric(base, g, n0, k){
  if (k<=0) return 0;
  const a0 = base * Math.pow(g, n0);
  return a0 * (Math.pow(g, k) - 1) / (g - 1);
}
function maxAffordableEff(){
  const g = 1.5;
  const base = G.meta.essenceEffBase ?? Math.max(100, 0.5 * num(getEssenceRefCost()));
  const n0 = G.ess.effLevel;
  const have = num(G.mana.amount);
  if (have <= 0) return 0;
  const a0 = base * Math.pow(g, n0);
  const k = Math.floor(Math.log( (have*(g-1))/a0 + 1 ) / Math.log(g));
  return Math.max(0, k);
}
function maxAffordableInfusions(elem){
  let have = Math.floor(G.ess.elements[elem] || 0);
  let k = 0;
  while (true){
    const c = infusionCost(elem, k);
    if (have >= c){ have -= c; k++; } else break;
  }
  return k;
}

/* ===== spell effect helpers (used by stored fns) ===== */
function giveEssence(S, elem){
  const y = essenceYield(elem);
  const whole = Math.floor(y);
  const frac = y - whole;
  if (whole>0) S.ess.elements[elem] += whole;
  if (Math.random() < frac) S.ess.elements[elem] += 1;
  S.ess.mastery[elem] += CFG.essenceMasteryPerCast;
}

/* ===== actions ===== */
function unlockNextSpell(){
  if (G.meta.dead) return false;
  const next = G.mana.spellIdx + 1;
  if (next >= SPELLS.length) return false;
  const s = SPELLS[next];
  const cost = s.unlockCost;
  if (!canAffordMana(cost)) return false;
  spendMana(cost);
  G.mana.unlocked[next] = true;
  G.mana.spellIdx = next;
  if (s.conjures) G.ess.unlocked = true;
  return true;
}

function castCurrentSpell(k=1){
  const idx = G.mana.spellIdx;
  return castByIndex(idx, k);
}

function castByIndex(idx, k=1){
  if (G.meta.dead) return false;
  if (!G.mana.unlocked[idx]) return false;
  const s = SPELLS[idx];
  k = Math.max(1, Math.floor(k));

  // Spend mana using geometric sum
  const base = num(s.baseCost);
  const g = s.growth;
  const n0 = G.mana.casts[idx] || 0;
  const spend = totalCostGeometric(base, g, n0, k);
  if (num(G.mana.amount) + 1e-12 < spend) return false; // cannot afford
  spendMana(D(spend));

  // Call the spell's stored function
  if (typeof s.fn === "function") s.fn(G, k);

  G.mana.casts[idx] = n0 + k;
  return true;
}

function buyEssenceEfficiency(k=1){
  if (G.meta.dead) return false;
  k = Math.max(1, Math.floor(k));
  const g = 1.5;
  const base = G.meta.essenceEffBase ?? Math.max(100, 0.5 * num(getEssenceRefCost()));
  const n0 = G.ess.effLevel;
  const spend = totalCostGeometric(base, g, n0, k);
  if (num(G.mana.amount) + 1e-12 < spend) return false;
  spendMana(D(spend));
  G.ess.effLevel += k;
  return true;
}

function buyInfusion(elem, k=1){
  if (G.meta.dead) return false;
  k = Math.max(1, Math.floor(k));
  let bought = 0;
  for(let i=0;i<k;i++){
    const cost = infusionCost(elem, bought);
    if ((G.ess.elements[elem]||0) >= cost){
      G.ess.elements[elem] -= cost;
      G.ess.infusions[elem] = (G.ess.infusions[elem]||0) + 1;
      bought++;
    } else break;
  }
  return bought>0;
}

/* ===== aging & rebirth ===== */
function ageTick(dt){
  if (G.meta.dead) return;
  G.meta.ageYears += dt * CFG.yearsPerSecond; // 75 yrs over 1200s
  if (G.meta.ageYears >= G.meta.lifespanYears){
    onDeath();
  }
}
function onDeath(){
  if (G.meta.dead) return;
  G.meta.dead = true;
}
function reincarnate(){
  // Compute knowledge factor based on ending mana; ensure never <1
  const endMana = Math.max(1, num(G.mana.amount));
  const factor = Math.max(1, Math.pow(Math.log10(endMana), 0.1));
  const prev = {
    globalMult: G.meta.globalMult,
    knowledgeMult: G.meta.knowledgeMult * factor,
    lifespanYears: G.meta.lifespanYears,
    rebirths: (G.meta.rebirths||0) + 1,
  };
  // Reset most state
  G = defaultState();
  G.meta.globalMult = prev.globalMult;
  G.meta.knowledgeMult = prev.knowledgeMult;
  G.meta.lifespanYears = prev.lifespanYears;
  G.meta.rebirths = prev.rebirths;
  G.meta.ageYears = 0;
  G.meta.dead = false;
  recalc(); render(); markSave("Reborn ✨");
}

/* ===== loop ===== */
let last=performance.now(), acc=0, fps=0, fC=0, fT=0;
function recalc(){ G.mana.perSec = D(G.mana.baseMPS * layerMult()); }
function tick(dt){
  if (!G.meta.dead){
    G.mana.amount = G.mana.amount.add(G.mana.perSec.mul(dt));
  }
}
function loop(now){
  const dt=(now-last)/1000; last=now; acc+=dt; fC++; fT+=dt;
  if(fT>=1){fps=fC; fC=0; fT=0; document.getElementById("fps").textContent=fps;}
  const step=1/20;
  while(acc>=step){
    recalc();
    tick(step);
    ageTick(step);
    acc-=step;
  }
  if (Math.random()<0.45) render();
  requestAnimationFrame(loop);
}

/* ===== UI ===== */
const $=q=>document.querySelector(q);
function fmtInt(n){ return Math.floor(n).toString(); }
function headerLine(name, amount, perSec, colorVar){
  const col = getComputedStyle(document.documentElement).getPropertyValue(colorVar)||colorVar;
  return `<div class="line">
    <div>
      <div style="font-weight:600;color:${col}">${name}</div>
      <div class="sub">Have <b>${fmt(amount)}</b> • +${fmt(perSec)}/s</div>
    </div>
  </div>`;
}

function manaPanel(){
  const s = currentSpell();
  const castN = G.mana.casts[G.mana.spellIdx]||0;
  const cost = nextCastCost(G.mana.spellIdx);
  const canCast = G.mana.amount.gte(cost) && !G.meta.dead;
  const next = G.mana.spellIdx+1 < SPELLS.length ? SPELLS[G.mana.spellIdx+1] : null;
  const canUnlock = next ? G.mana.amount.gte(next.unlockCost) && !G.meta.dead : false;

  // Describe growth — generator vs essence
  const growthText = s.conjures ? `conjures essence` : `cost +${((s.growth - 1) * 100).toFixed(2)}%/cast`;

  const maxCurr = maxAffordableCasts(G.mana.spellIdx);

  const essenceBtns = SPELLS.map((sp, i) => ({sp, i}))
    .filter(x => x.sp.conjures && G.mana.unlocked[x.i])
    .map(({sp,i})=>{
      const n = G.mana.casts[i]||0;
      const c = nextCastCost(i);
      const afford = G.mana.amount.gte(c) && !G.meta.dead;
      const elem = sp.elem;
      const y = essenceYield(elem);
      const col = ({fire:"var(--fire)", ice:"var(--ice)", earth:"var(--earth)", wind:"var(--wind)"})[elem] || "var(--ess)";
      const kmax = maxAffordableCasts(i);
      return `
        <div>
          <div class="tiny"><b style="color:${col}">${sp.name}</b> — yields ~${fmtInt(Math.round(y))} ${elem} (casts: ${n})</div>
          <div class="btnrow">
            <button class="btn ${afford?'good':''}" ${afford?'':'disabled'} onclick="UI.castIdx(${i})">${sp.name} — Cost ${fmt(c)}</button>
            <button class="btn ${kmax>0&&!G.meta.dead?'warn':''}" ${kmax>0&&!G.meta.dead?'':'disabled'} onclick="UI.castMaxIdx(${i})">Max (${kmax})</button>
          </div>
        </div>
      `;
    }).join("");

  // Death banner
  const deathBar = G.meta.dead ? `
    <div class="deadbar">
      <div style="display:flex;justify-content:space-between;gap:10px;align-items:center">
        <div>
          <div style="font-weight:700">Your wizard has passed on at age ${G.meta.ageYears.toFixed(1)}.</div>
          <div class="tiny">Ending mana: <b>${fmt(G.mana.amount)}</b>. New Knowledge factor will multiply your mana forever.</div>
        </div>
        <button class="btn good" onclick="UI.reincarnate()">Pass On (Reincarnate)</button>
      </div>
    </div>
  ` : "";

  return `
  <section class="mod" style="border-color:${getComputedStyle(document.documentElement).getPropertyValue('--mana')}44">
    <h3>Mana <span class="badge">Spellbook</span></h3>
    ${deathBar}
    ${headerLine("Mana", G.mana.amount, G.mana.perSec, "--mana")}
    <div class="hr"></div>

    <div class="tiny"><b>${s.name}</b> — ${growthText}</div>
    <div class="btnrow">
      <button class="btn ${canCast?'good':''}" ${canCast?'':'disabled'} onclick="UI.castCurrent()">
        ${s.name} — Cost ${fmt(cost)} ${!s.conjures?'MP':''} (casts: ${castN})
      </button>
      <button class="btn ${maxCurr>0&&!G.meta.dead?'warn':''}" ${maxCurr>0&&!G.meta.dead?'':'disabled'} onclick="UI.castMaxCurrent()">Max (${maxCurr})</button>
    </div>

    ${next?`
    <div class="hr"></div>
    <div class="tiny"><b>Unlock Next Spell:</b> ${next.name}</div>
    <button class="btn ${canUnlock?'warn':''}" ${canUnlock?'':'disabled'} onclick="UI.unlockSpell()">
      Unlock — Cost ${fmt(next.unlockCost)} MP
    </button>`:""}

    ${essenceBtns?`<div class="hr"></div><div class="ess-list">${essenceBtns}</div>`:""}
  </section>`;
}

function essPanel(){
  const e = G.ess;
  const mult = essenceEffTotal();
  const effCost = essenceEffCost();
  const canEff = G.mana.amount.gte(effCost) && !G.meta.dead;
  const maxEff = maxAffordableEff();

  function conjUnlocked(elemKey){
    const idx = SPELLS.findIndex(s => s.conjures && s.elem===elemKey);
    return idx>=0 && G.mana.unlocked[idx];
  }

  function infusionLine(label, elem, colorVar){
    if (!conjUnlocked(elem)) return ""; // hidden until its Conjure unlocked
    const need = infusionCost(elem);
    const have = Math.floor(e.elements[elem]||0);
    const lvl = e.infusions[elem]||0;
    const can = have >= need && !G.meta.dead;
    const kmax = maxAffordableInfusions(elem);
    const col = getComputedStyle(document.documentElement).getPropertyValue(colorVar)||colorVar;
    return `
      <div class="line" style="align-items:flex-start;gap:12px;flex-direction:column">
        <div style="width:100%;display:flex;justify-content:space-between;gap:10px">
          <div>
            <div><b style="color:${col}">${label} Infusion</b> <span class="badge">Lvl ${lvl}</span></div>
            <div class="tiny">Effect: Global mana ×2 per level (stacks)</div>
          </div>
          <div class="tiny" style="text-align:right">
            Cost: <b>${fmtInt(need)}</b> ${label} Essence • You: <b>${fmtInt(have)}</b>
          </div>
        </div>
        <div class="btnrow" style="width:100%">
          <button class="btn ${can?'good':''}" ${can?'':'disabled'} onclick="UI.buyInfusion('${elem}')">Buy</button>
          <button class="btn ${kmax>0&&!G.meta.dead?'warn':''}" ${kmax>0&&!G.meta.dead?'':'disabled'} onclick="UI.buyInfusionMax('${elem}')">Max (${kmax})</button>
        </div>
      </div>
    `;
  }

  return `
  <section class="mod" style="border-color:${getComputedStyle(document.documentElement).getPropertyValue('--ess')}44">
    <h3>Essences <span class="badge">Per-Element</span></h3>
    <!-- rounded essence counts in pills -->
    <div class="line">
      <div class="pill mono" style="border-color:#fff2">🪨 ${fmtInt(e.elements.earth||0)}</div>
      <div class="pill mono" style="border-color:#fff2">❄️ ${fmtInt(e.elements.ice||0)}</div>
      <div class="pill mono" style="border-color:#fff2">🔥 ${fmtInt(e.elements.fire||0)}</div>
      <div class="pill mono" style="border-color:#fff2">💨 ${fmtInt(e.elements.wind||0)}</div>
    </div>

    <div class="hr"></div>
    <div class="tiny"><b>Essence Efficiency</b> — Total essence gain ×<b>${(mult>=10?mult.toFixed(1):mult.toFixed(2))}</b></div>
    <div class="btnrow">
      <button class="btn ${canEff?'warn':''}" ${canEff?'':'disabled'} onclick="UI.buyEff()">Upgrade — Cost ${fmt(effCost)} MP</button>
      <button class="btn ${maxEff>0&&!G.meta.dead?'warn':''}" ${maxEff>0&&!G.meta.dead?'':'disabled'} onclick="UI.buyEffMax()">Max (${maxEff})</button>
    </div>

    <div class="hr"></div>
    ${infusionLine("Earth","earth","--earth")}
    ${infusionLine("Ice","ice","--ice")}
    ${infusionLine("Fire","fire","--fire")}
    ${infusionLine("Wind","wind","--wind")}
  </section>`;
}

function render(){
  // panels
  const panels=[];
  panels.push(manaPanel());
  if (G.ess.unlocked) panels.push(essPanel());
  $("#grid").innerHTML = panels.join("");

  // header chips
  const infCount = (G.ess.infusions.fire||0)+(G.ess.infusions.ice||0)+(G.ess.infusions.earth||0)+(G.ess.infusions.wind||0);
  $("#infusions").textContent = infCount;
  $("#globalMult").textContent = (G.meta.globalMult * Math.pow(2, infCount)).toFixed(2);
  $("#knowledgeMult").textContent = (G.meta.knowledgeMult).toFixed(2);
  $("#ageYears").textContent = G.meta.ageYears.toFixed(1);
  $("#lifeYears").textContent = G.meta.lifespanYears.toFixed(0);
}

/* ===== save/load ===== */
function save(){
  const o=JSON.parse(JSON.stringify(G));
  localStorage.setItem(SAVE_KEY, JSON.stringify(o));
  markSave("Saved ✔");
}
function load(){
  const raw=localStorage.getItem(SAVE_KEY); if(!raw) return null;
  const o=JSON.parse(raw);
  o.mana.amount = Dec.fromJSON(o.mana.amount);
  o.mana.perSec = Dec.fromJSON(o.mana.perSec);
  return o;
}
let saveTimer=null; 
function markSave(msg){
  clearTimeout(saveTimer);
  document.getElementById("saveMsg").textContent=msg;
  saveTimer=setTimeout(()=>document.getElementById("saveMsg").textContent="Autosaving…",1500);
}

/* ===== UI API ===== */
const UI = {
  castCurrent: ()=>{ if(castCurrentSpell()) render(); },
  castMaxCurrent: ()=>{ const k=maxAffordableCasts(G.mana.spellIdx); if(k>0 && castCurrentSpell(k)) render(); },
  castIdx: (i)=>{ if(castByIndex(i)) render(); },
  castMaxIdx: (i)=>{ const k=maxAffordableCasts(i); if(k>0 && castByIndex(i,k)) render(); },
  unlockSpell: ()=>{ if(unlockNextSpell()) render(); },
  buyEff: ()=>{ if(buyEssenceEfficiency()) render(); },
  buyEffMax: ()=>{ const k=maxAffordableEff(); if(k>0 && buyEssenceEfficiency(k)) render(); },
  buyInfusion: (k)=>{ if(buyInfusion(k)) render(); },
  buyInfusionMax: (elem)=>{ const m=maxAffordableInfusions(elem); if(m>0 && buyInfusion(elem,m)) render(); },
  reincarnate: ()=>{ reincarnate(); },
};
window.UI = UI;

/* ===== boot ===== */
function init(){
  const loadFromSave = false;
  if(loadFromSave){
    const loaded = load();
    if (loaded){
      G = Object.assign(defaultState(), loaded);
      G.ess.mastery = G.ess.mastery || {fire:0,ice:0,earth:0,wind:0};
    }
  }
  // simple offline
  const now=Date.now();
  const elapsed=Math.min(12*3600, Math.max(0,(now-(G.meta.last||now))/1000));
  G.meta.last=now;
  recalc(); if(elapsed>0){ G.mana.amount = G.mana.amount.add( manaPerSec().mul(elapsed) ); }
  render();
  setInterval(()=>{ G.meta.last=Date.now(); save(); }, 10_000);
  requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>
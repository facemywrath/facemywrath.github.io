<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Maze-Sweeper</title>
<style>
  :root { --cell: 36px; --gap: 2px; }
  * { box-sizing: border-box; }
  body {
    margin: 0; background: #0f0f13; color: #e8e8ef; font-family: system-ui, sans-serif;
    display: grid; grid-template-rows: auto 1fr auto; min-height: 100dvh;
  }
  .topbar {
    display:flex; gap:16px; align-items:center; padding:10px 14px;
  }
  .hearts { display:flex; gap:6px; align-items:center; }
  .heart {
    width: 22px; height: 22px; border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #ff6a7a, #e0143a 70%);
    box-shadow: 0 0 10px #e0143a66 inset, 0 0 3px #e0143a66;
  }
.cell.wall-revealed { 
  background:#5b5a5a !important; 
  color:#e6c39a !important; 
}
  .heart.empty {
    background: radial-gradient(circle at 35% 35%, #4a4a55, #2a2a33 70%);
    box-shadow: 0 0 10px #000 inset;
    filter: grayscale(0.4);
  }
  .score { margin-left:auto; font-weight:700; letter-spacing:0.3px; }

  .mode-btn {
    border: 0; border-radius: 10px; padding: 6px 10px; font-weight: 800;
    background:#23263a; color:#e8e8ef; box-shadow: 0 0 0 1px #2a2f44 inset;
    cursor:pointer;
  }

  .stage-wrap { display:grid; place-items:center; padding:8px 12px; }
  .grid {
    display:grid;
    grid-template-columns: repeat(16, var(--cell));
    grid-template-rows: repeat(16, var(--cell));
    gap: var(--gap);
    background: #14141b;
    padding: var(--gap);
    border-radius: 10px;
    box-shadow: 0 0 0 1px #242436 inset, 0 10px 30px #0008;
    user-select:none;
    touch-action: manipulation;
  }
  .cell {
    width: var(--cell); height: var(--cell);
    display:flex; align-items:center; justify-content:center;
    font-weight: 800; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    border-radius: 6px;
    transition: transform 80ms ease, background 120ms ease, color 120ms ease, box-shadow 120ms ease;
    box-shadow: 0 1px 0 #000a inset;
    cursor: pointer;
  }
  .cell.unrevealed { background:#1a1b22; color:transparent; }
  .cell.wall { background:#252632; color:#7b7c8f; }
  .cell.clear.revealed { background:#101319; color:#d9dbff; }
  .cell.mine.revealed { background:#2a1015; color:#ff6e6e; }
  .cell.trail { background:#3e3a1a !important; color:#ffe7a7 !important; }
  .cell.current { background:#0c4a2f !important; color:#b7ffcf !important; outline: 2px solid #1cff8a50; }

  .n1{color:#77dfff}.n2{color:#6dffa6}.n3{color:#ffe37a}.n4{color:#ffb870}
  .n5{color:#ff8e8e}.n6{color:#f58bff}.n7{color:#b6b6ff}.n8{color:#dcdcdc}

  .cell.bomb-current { background:#5a1a75 !important; color:#fff !important; } /* purple */
  .cell.bomb-stepped { background:#7a1a1a !important; color:#fff !important; } /* red */

  .controls { display:grid; place-items:center; padding:10px 0 16px; }
  .dpad { display:grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px 60px; gap:10px; }
  .dpad button {
    border: 0; border-radius: 14px; font-size: 18px; font-weight:800;
    background:#1e2232; color:#e8e8ef; box-shadow: 0 6px 16px #0007, 0 0 0 1px #2a2f44 inset;
    transition: transform 70ms ease, background 70ms ease;
    touch-action: manipulation;
  }
  .dpad button:active { transform: translateY(1px) scale(0.98); background:#24293e; }
  .btn-wide {
    margin-top: 14px; padding:10px 16px; border-radius: 12px; font-weight:800;
    border:0; background:#23263a; color:#e8e8ef; box-shadow: 0 0 0 1px #2a2f44 inset;
  }

  .toast, .overlay { position: fixed; inset: auto 0 16px 0; display:flex; justify-content:center; pointer-events:none; }
  .toast .msg { background:#1d1f2a; color:#e8e8ef; padding:10px 14px; border-radius:10px; box-shadow:0 6px 24px #0009; }
  .overlay { position: fixed; inset:0; background:#0008; align-items:center; justify-content:center; z-index:100; display:none; pointer-events:auto; }
  .overlay .card { pointer-events: auto; background:#171923; border-radius: 16px; padding: 18px; box-shadow: 0 18px 60px #000a, 0 0 0 1px #2a2f44 inset; width:min(92vw, 460px); text-align:center; }
  .card h2 { margin: 0 0 8px; }
  .card p { opacity: 0.9; }
  .card .row { display:flex; justify-content:space-between; gap:12px; margin-top:10px; }
  .card .row .btn { flex:1 1 auto; padding:10px; border-radius:12px; border:0; font-weight:800; }
  .btn-primary { background:#0f8f58; color:white; }
  .pulse { animation:pulse 800ms ease-in-out; }
  @keyframes pulse { 0%{transform:scale(1)} 50%{transform:scale(1.05)} 100%{transform:scale(1)} }
  @media (max-width: 640px) {
    :root { --cell: 28px; }
    .dpad { grid-template-columns: 56px 56px 56px; grid-template-rows: 56px 56px 56px; }
  }
</style>
</head>
<body>
<div class="topbar">
  <button id="btnMode" class="mode-btn" title="Toggle mode">Mode: Classic</button>
  <button id="btnHelp" class="mode-btn" title="How to play">?</button>
  <div class="hearts" id="hearts"></div>
  <div class="score" id="score">Score: 0</div>
</div>

  <div class="stage-wrap">
    <div class="grid" id="grid" aria-label="MazeSweeper grid"></div>
  </div>

  <div class="controls">
    <div class="dpad" aria-label="Move buttons">
      <div></div>
      <button id="btnUp"    aria-label="Up">â–²</button>
      <div></div>
      <button id="btnLeft"  aria-label="Left">â—€</button>
      <div></div>
      <button id="btnRight" aria-label="Right">â–¶</button>
      <div></div>
      <button id="btnDown"  aria-label="Down">â–¼</button>
      <div></div>
    </div>
    <button class="btn-wide" id="btnNew">New Game</button>
  </div>

  <div class="toast" id="toast" style="display:none;"><div class="msg" id="toastMsg"></div></div>
  <div class="overlay" id="overlay" style="display:none;">
    <div class="card">
      <h2 id="ovTitle">You Win!</h2>
      <p id="ovText"></p>
      <div class="row">
        <button class="btn btn-primary" id="btnAgain">Restart</button>
      </div>
    </div>
  </div>
  <div class="overlay" id="helpOverlay" style="display:none;">
  <div class="card">
    <h2>How to Play</h2>
    <p style="text-align:left;line-height:1.4">
      <strong>Goal:</strong> Move from the top-left to the bottom-right.<br><br>
      <strong>Cells:</strong> Every revealed cell shows the number of adjacent bombs (like Minesweeper),
      even on walls and bombs. Green = your current cell, yellow = your trail. Stepping on a bomb turns it purple while you stand on it, then red after.<br><br>
      <strong>Movement:</strong> Tap/click an adjacent cell or use the D-pad/arrow keys.<br><br>
      <strong>Classic:</strong> Start with 3 lives and a score baseline. Reaching the goal shows a win screen.
      Bombs cost a life and âˆ’75 score. <em>High score saves only if you win.</em><br><br>
      <strong>Discovery:</strong> Endless runs. Score +1 the first time you reveal any cell.
      Reaching the goal or revealing <em>every cell</em> resets to a fresh board <em>without</em> losing score or lives.
      <em>High score updates as you play.</em>
    </p>
    <div class="row">
      <button class="btn btn-primary" id="btnHelpClose">Close</button>
    </div>
  </div>
</div>

<script>
(() => {
  const SIZE = 16;
  const START = {x:0, y:0}, GOAL = {x: SIZE-1, y: SIZE-1};
  const START_LIVES = 3;
  const MINE_RATE = 0.4;

  // Modes: "classic" (original rules) or "discovery" (infinite)
  let MODE = 'classic';

  let grid = [];
  let pathCells = new Set();
  let pos = {x:START.x, y:START.y};
  let lives = START_LIVES;
  let score = 0;
  let discovered = 0;     // cumulative discoveries across boards in discovery mode too

// NEW: LocalStorage keys and helpers
  const HS_KEYS = { classic: 'mazeSweeperHighClassic', discovery: 'mazeSweeperHighDiscovery' };

  function getHigh(mode){
    const v = localStorage.getItem(HS_KEYS[mode] || '');
    return v ? parseInt(v, 10) || 0 : 0;
  }
  function maybeSetHigh(mode, value){
    const k = HS_KEYS[mode]; if(!k) return;
    const cur = getHigh(mode);
    if(value > cur){
      localStorage.setItem(k, String(value));
    }
  }
  const el = {
    helpOverlay: document.getElementById('helpOverlay'), // NEW
    btnHelp: document.getElementById('btnHelp'),         // NEW
    btnHelpClose: document.getElementById('btnHelpClose'),
    grid: document.getElementById('grid'),
    hearts: document.getElementById('hearts'),
    score: document.getElementById('score'),
    toast: document.getElementById('toast'),
    toastMsg: document.getElementById('toastMsg'),
    overlay: document.getElementById('overlay'),
    ovTitle: document.getElementById('ovTitle'),
    ovText: document.getElementById('ovText'),
    btnAgain: document.getElementById('btnAgain'),
    btnNew: document.getElementById('btnNew'),
    btnMode: document.getElementById('btnMode'),
  };

  const key = (x,y)=>`${y},${x}`;
  const inBounds = (x,y)=> x>=0 && x<SIZE && y>=0 && y<SIZE;
  const shuffle = (arr)=>{ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]] } return arr; }

  function showToast(msg, ms=900){
    el.toastMsg.textContent = msg;
    el.toast.style.display = 'flex';
    el.toast.classList.add('pulse');
    setTimeout(()=>{ el.toast.style.display='none'; el.toast.classList.remove('pulse'); }, ms);
  }

  function showOverlay(title, text){
    el.ovTitle.textContent = title;
    el.ovText.textContent = text;
    el.overlay.style.display = 'flex';
    el.grid.style.pointerEvents = "none";
  }
  function hideOverlay(){
    el.overlay.style.display = 'none';
    el.grid.style.pointerEvents = "auto";
  }

  function generateSinglePath(){
    const visited = Array.from({length:SIZE},()=>Array(SIZE).fill(false));
    const path = [];
    let solved = false;
    function dfs(x,y){
      if(solved) return true;
      visited[y][x] = true;
      path.push([x,y]);
      if(x===GOAL.x && y===GOAL.y){ solved = true; return true; }
      const dirs = shuffle([[1,0],[-1,0],[0,1],[0,-1]]);
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(inBounds(nx,ny) && !visited[ny][nx]){
          if(dfs(nx,ny)) return true;
        }
      }
      path.pop();
      return false;
    }
    dfs(START.x, START.y);
    return path;
  }

  function buildGrid(){
  const p = generateSinglePath();
  pathCells = new Set(p.map(([x,y])=>key(x,y)));

  grid = Array.from({length:SIZE},(_,y)=>
    Array.from({length:SIZE},(_,x)=>({ type:'wall', number:0, revealed:false, visited:false, steppedOn:false }))
  );

  for (const [x,y] of p) grid[y][x].type = 'clear';
  for (let y=0;y<SIZE;y++){
    for (let x=0;x<SIZE;x++){
      if(!pathCells.has(key(x,y))){
        grid[y][x].type = (Math.random() < MINE_RATE) ? 'mine' : 'wall';
      }
    }
  }

  // Count adjacent mines (8-neighbors)
  const dirs8 = [-1,0,1].flatMap(dy => [-1,0,1].map(dx=>[dx,dy]));
  for (let y=0;y<SIZE;y++){
    for (let x=0;x<SIZE;x++){
      let c=0;
      for (const [dx,dy] of dirs8){
        const nx=x+dx, ny=y+dy;
        if (inBounds(nx,ny) && grid[ny][nx].type==='mine') c++;
      }
      grid[y][x].number = c;
    }
  }

  // >>> NEW: ensure every passable pocket connects to the main region
  connectPockets();
} 

  function renderGrid(){
    el.grid.innerHTML = '';
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const c = document.createElement('div');
        c.className = 'cell unrevealed';
        c.dataset.x = x; c.dataset.y = y;
        el.grid.appendChild(c);
      }
    }
    grid[START.y][START.x].revealed = true;
    grid[START.y][START.x].visited = true;
    updateCell(START.x, START.y, {current:true});
    updateHUD();
  }

  function updateHUD(){
    el.hearts.innerHTML = '';
    for(let i=0;i<START_LIVES;i++){
      const h = document.createElement('div');
      h.className = 'heart' + (i < lives ? '' : ' empty');
      el.hearts.appendChild(h);
    }
    const high = getHigh(MODE);
    el.score.textContent = `Score: ${score}  (High: ${high})`;
  }
  // NEW: detect when every cell on the board is revealed
  function isBoardFullyRevealed(){
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        if(!grid[y][x].revealed) return false;
      }
    }
    return true;
  }

  // NEW: call after any reveal in discovery
  function maybeAdvanceDiscoveryOnFullReveal(){
    if(MODE !== 'discovery') return;
    if(isBoardFullyRevealed()){
      showToast("Area fully explored â†’");
      nextDiscoveryBoard(); // keeps score & lives
    }
  }
  function applyDiscoveryScoring(didReveal){
    if(!didReveal) return;
    if (MODE === 'discovery') {
      score += 1;
      maybeSetHigh('discovery', score); // NEW: live highscore updates
    } else {
      score = Math.max(0, score - 1);
    }
  }

  function updateCell(x,y,{current=false}={}){
  const idx = y*SIZE + x;
  const node = el.grid.children[idx];
  const cell = grid[y][x];

  node.className = 'cell';

  if (!cell.revealed) {
    node.classList.add('unrevealed');
    node.textContent = '';
  } else {
    node.classList.add('revealed');

    // Type-based styling
    if (cell.type === 'wall') {
      node.classList.add('wall-revealed'); // <<< NEW brown walls
    } else if (cell.type === 'mine') {
      if (cell.popped) node.textContent = "ðŸ’¥";
      if (current) node.classList.add('bomb-current');
      else if (cell.steppedOn) node.classList.add('bomb-stepped');
    }

    // Numbers (still show counts for all cell types)
    const n = cell.number;
    if (node.textContent === '') { // don't overwrite ðŸ’¥
      node.textContent = n>0 ? String(n) : '';
    }
    if (n>=1 && n<=8) node.classList.add('n'+n);

    if (cell.visited && !current) node.classList.add('trail');
  }

  if (current && cell.type!=='mine') node.classList.add('current');
}

  function setCurrent(x,y){
    const prev = grid[pos.y][pos.x];
    if(prev.type==='mine' && prev.revealed){
      prev.steppedOn = true;
      updateCell(pos.x,pos.y,{current:false});
    } else {
      updateCell(pos.x,pos.y,{current:false});
    }

    pos = {x,y};
    grid[y][x].visited = true;
    updateCell(x,y, {current:true});
  }

  // Discovery scoring: +1 for first-time reveal; Classic: â€“1 (min 0) for reveal (original behavior)
  function applyDiscoveryScoring(didReveal){
    if(!didReveal) return;
    if (MODE === 'discovery') {
      score += 1;
    } else {
      score = Math.max(0, score - 1);
    }
  }
// Passable = anything that's not a wall (you can step on mines)
function isPassable(x, y) {
  return inBounds(x,y) && grid[y][x].type !== 'wall';
}

// Flood-fill (BFS) to mark all passable cells reachable from START
function floodFromStart() {
  const seen = Array.from({length: SIZE}, () => Array(SIZE).fill(false));
  const q = [[START.x, START.y]];
  while (q.length) {
    const [x,y] = q.shift();
    if (!inBounds(x,y) || seen[y][x] || !isPassable(x,y)) continue;
    seen[y][x] = true;
    q.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
  }
  return seen; // seen[y][x] true = reachable
}

// Find all unreachable passable "pockets" and connect each by carving one wall between it and the reachable region
function connectPockets() {
  while (true) {
    const seen = floodFromStart();

    // Collect one cell from each unreachable pocket (passable but not seen)
    const pockets = [];
    const taken = Array.from({length: SIZE}, () => Array(SIZE).fill(false));

    function bfsPocket(sx, sy) {
      const q = [[sx, sy]];
      taken[sy][sx] = true;
      const cells = [[sx, sy]];
      while (q.length) {
        const [x,y] = q.shift();
        for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
          const nx = x+dx, ny = y+dy;
          if (!inBounds(nx,ny) || taken[ny][nx]) continue;
          if (isPassable(nx,ny) && !seen[ny][nx]) {
            taken[ny][nx] = true;
            q.push([nx,ny]);
            cells.push([nx,ny]);
          }
        }
      }
      return cells;
    }

    for (let y=0; y<SIZE; y++) {
      for (let x=0; x<SIZE; x++) {
        if (isPassable(x,y) && !seen[y][x] && !taken[y][x]) {
          pockets.push(bfsPocket(x,y)); // store list of cells in this pocket
        }
      }
    }

    if (pockets.length === 0) break; // all connected

    // For each pocket, carve a single wall that borders the reachable region
    for (const cells of pockets) {
      let carved = false;

      // Try to find a boundary wall that touches both: reachable cell AND this pocket
      for (const [px,py] of cells) {
        for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
          const wx = px+dx, wy = py+dy; // candidate wall between pocket & reachable
          if (!inBounds(wx,wy) || grid[wy][wx].type !== 'wall') continue;

          // Does this wall also touch a reachable passable cell on its other side?
          // Look on the opposite side of the wall
          const rx = wx+dx, ry = wy+dy;
          if (inBounds(rx,ry) && seen[ry][rx] && isPassable(rx,ry)) {
            grid[wy][wx].type = 'clear'; // carve!
            carved = true;
            break;
          }
        }
        if (carved) break;
      }

      // Fallback: if we didn't find a perfect opposite-side pair, carve any wall that borders a reachable cell
      if (!carved) {
        outer:
        for (let y=0; y<SIZE; y++) {
          for (let x=0; x<SIZE; x++) {
            if (grid[y][x].type !== 'wall') continue;
            let touchesPocket = false, touchesSeen = false;
            for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
              const nx = x+dx, ny = y+dy;
              if (!inBounds(nx,ny)) continue;
              if (isPassable(nx,ny) && !seen[ny][nx]) touchesPocket = true;
              if (isPassable(nx,ny) && seen[ny][nx])  touchesSeen   = true;
            }
            if (touchesPocket && touchesSeen) {
              grid[y][x].type = 'clear';
              carved = true;
              break outer;
            }
          }
        }
      }
    }

    // Loop again in case carving one pocket exposes another; we exit when no pockets remain
  }
}
  function gainDiscovery(x,y){
    const cell = grid[y][x];
    if(!cell.revealed){
      cell.revealed = true;
      discovered++;
      applyDiscoveryScoring(true);
      updateCell(x,y);
      updateHUD();
      if (MODE === 'discovery') { // NEW
        maybeAdvanceDiscoveryOnFullReveal();
      }
      return true;
    }
    return false;
  }

  function revealOrthogonalNeighbors(x,y){
    const orth = [[1,0],[-1,0],[0,1],[0,-1]];
    let any = false; // NEW
    for(const [dx,dy] of orth){
      const nx = x+dx, ny = y+dy;
      if(!inBounds(nx,ny)) continue;
      const didReveal = gainDiscovery(nx, ny);
      any = any || didReveal; // NEW
    }
    if (any && MODE === 'discovery') { // NEW
      maybeAdvanceDiscoveryOnFullReveal();
    }
  }

  function tryMove(dx,dy){
    const nx = pos.x + dx, ny = pos.y + dy;
    if(!inBounds(nx,ny)) { showToast("Edge of map"); return; }
    const dest = grid[ny][nx];
    if(dest.type === 'wall'){ cellFlash(nx,ny); showToast("Wall"); return; }

    const firstTime = gainDiscovery(nx,ny);

    if(dest.type === 'mine' && !dest.popped){
      lives--; 
      dest.popped = true;
      const idx = ny*SIZE + nx;
      const node = el.grid.children[idx];
      node.textContent = "ðŸ’¥"
      if(MODE == "classic"){
        score = Math.max(0, score - 75);
       showToast("ðŸ’¥ -1 life, -75 score");
      }
      updateHUD();
      setCurrent(nx,ny);
      revealOrthogonalNeighbors(nx,ny);
      if(lives <= 0){ gameOver(false); return; }
      // In discovery, keep going; in classic, also keep going (penalty already applied)
      return;
    }

    setCurrent(nx,ny);
    revealOrthogonalNeighbors(nx,ny);

    // Classic: reaching GOAL ends round with a win screen
    if (MODE === 'classic' && nx === GOAL.x && ny === GOAL.y) {
      gameOver(true);
    }

    // Discovery: reaching GOAL seamlessly generates a fresh board and continues (infinite)
    if (MODE === 'discovery' && nx === GOAL.x && ny === GOAL.y) {
      nextDiscoveryBoard();
    }
  }

  function cellFlash(x,y){
    const node = el.grid.children[y*SIZE+x];
    node.style.outline = '2px solid #ffca3a';
    setTimeout(()=> node.style.outline = '', 140);
  }

  function gameOver(win){
    const msg = win
      ? `Reached the goal with score ${score}, ${discovered} discoveries, ${lives} â¤ left.`
      : `You ran out of lives. Final score ${score}${MODE == "classic"?", discoveries "+discovered : ""}.`;
      // NEW: save highs only per requested rules
    if (MODE === 'classic' && win) {
      maybeSetHigh('classic', score);
    }
    // Discovery high is already handled live in applyDiscoveryScoring
    showOverlay(win? "You Win!" : "Game Over", msg);
  }

  // ---------- Mode / Board control ----------
  function nextDiscoveryBoard(){
    // Keep lives, score, and cumulative discovered. Just regenerate and place the player back at START.
    pos = {x:START.x, y:START.y};
    buildGrid();
    renderGrid();
    showToast("New area discovered â†’");
  }

  function newBoard(resetStats){
    hideOverlay();
    if (resetStats) {
      lives = START_LIVES;
      discovered = 0;
      score = (MODE === 'discovery') ? 0 : 250;  // discovery starts at 0; classic starts at 250 (original)
    }
    pos = {x:START.x, y:START.y};
    buildGrid();
    renderGrid();
  }

  function toggleMode(){
    MODE = (MODE === 'classic') ? 'discovery' : 'classic';
    el.btnMode.textContent = `Mode: ${MODE[0].toUpperCase()}${MODE.slice(1)}`;
    // When switching modes, start a fresh run with that mode's starting score policy
    newBoard(true);
  }

  // ---------- Events ----------
  el.grid.addEventListener('click', (e)=>{
    const t = e.target.closest('.cell'); if(!t) return;
    const x = +t.dataset.x, y = +t.dataset.y;
    const dx = x - pos.x, dy = y - pos.y;
    if(Math.abs(dx) + Math.abs(dy) !== 1){ showToast("Tap an adjacent cell"); return; }
    tryMove(Math.sign(dx), Math.sign(dy));
  });

  document.getElementById('btnUp').addEventListener('click', ()=>tryMove(0,-1));
  document.getElementById('btnDown').addEventListener('click', ()=>tryMove(0, 1));
  document.getElementById('btnLeft').addEventListener('click', ()=>tryMove(-1,0));
  document.getElementById('btnRight').addEventListener('click', ()=>tryMove(1, 0));

  el.btnNew.addEventListener('click', ()=> newBoard(true));
  el.btnAgain.addEventListener('click', ()=>{ newBoard(true); });
  el.btnMode.addEventListener('click', toggleMode);
// NEW: Help overlay
  el.btnHelp.addEventListener('click', ()=>{
    el.helpOverlay.style.display = 'flex';
    el.grid.style.pointerEvents = "none";
  });
  el.btnHelpClose.addEventListener('click', ()=>{
    el.helpOverlay.style.display = 'none';
    el.grid.style.pointerEvents = "auto";
  });
  window.addEventListener('keydown', (e)=>{
    if(el.overlay.style.display !== 'none') return;
    if(e.key==='ArrowUp'){ e.preventDefault(); tryMove(0,-1); }
    if(e.key==='ArrowDown'){ e.preventDefault(); tryMove(0, 1); }
    if(e.key==='ArrowLeft'){ e.preventDefault(); tryMove(-1,0); }
    if(e.key==='ArrowRight'){ e.preventDefault(); tryMove(1, 0); }
  });

  // ---------- Init ----------
  // Start in Classic by default (same as original); click Mode to switch to Discovery
  newBoard(true);
})();
</script>
</body>
</html>
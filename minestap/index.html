<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Maze-Sweeper</title>
<style>
  :root { --cell: 36px; --gap: 2px; }
  * { box-sizing: border-box; }
  body {
    margin: 0; background: #0f0f13; color: #e8e8ef; font-family: system-ui, sans-serif;
    display: grid; grid-template-rows: auto 1fr auto; min-height: 100dvh;
  }
  /* Top bar */
  .topbar {
    display:flex; gap:16px; align-items:center; padding:10px 14px;
  }
  .hearts { display:flex; gap:6px; align-items:center; }
  .heart {
    width: 22px; height: 22px; border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #ff6a7a, #e0143a 70%);
    box-shadow: 0 0 10px #e0143a66 inset, 0 0 3px #e0143a66;
  }
  .heart.empty {
    background: radial-gradient(circle at 35% 35%, #4a4a55, #2a2a33 70%);
    box-shadow: 0 0 10px #000 inset;
    filter: grayscale(0.4);
  }
  .score { margin-left:auto; font-weight:700; letter-spacing:0.3px; }

  /* Main area */
  .stage-wrap {
    display:grid; place-items:center; padding:8px 12px;
  }
  .grid {
    display:grid;
    grid-template-columns: repeat(16, var(--cell));
    grid-template-rows: repeat(16, var(--cell));
    gap: var(--gap);
    background: #14141b;
    padding: var(--gap);
    border-radius: 10px;
    box-shadow: 0 0 0 1px #242436 inset, 0 10px 30px #0008;
    user-select:none;
    touch-action: manipulation;
  }
  .cell {
    width: var(--cell); height: var(--cell);
    display:flex; align-items:center; justify-content:center;
    font-weight: 800; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    border-radius: 6px;
    transition: transform 80ms ease, background 120ms ease, color 120ms ease, box-shadow 120ms ease;
    box-shadow: 0 1px 0 #000a inset;
    cursor: pointer;
  }
  .cell.unrevealed { background:#1a1b22; color:transparent; }
  .cell.wall { background:#252632; color:#7b7c8f; }
  .cell.clear.revealed { background:#101319; color:#d9dbff; }
  .cell.mine.revealed { background:#2a1015; color:#ff6e6e; }
  .cell.trail { background:#3e3a1a !important; color:#ffe7a7 !important; }
  .cell.current { background:#0c4a2f !important; color:#b7ffcf !important; outline: 2px solid #1cff8a50; }

  /* Number coloring for fun */
  .n1{color:#77dfff}.n2{color:#6dffa6}.n3{color:#ffe37a}.n4{color:#ffb870}
  .n5{color:#ff8e8e}.n6{color:#f58bff}.n7{color:#b6b6ff}.n8{color:#dcdcdc}
.cell.bomb-current {
  background:#5a1a75 !important;  /* purple */
  color:#fff !important;
}
.cell.bomb-stepped {
  background:#7a1a1a !important;  /* red */
  color:#fff !important;
}
  /* Bottom controls */
  .controls {
    display:grid; place-items:center; padding:10px 0 16px;
  }
  .dpad {
    display:grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px 60px;
    gap:10px;
  }
  .dpad button {
    border: 0; border-radius: 14px; font-size: 18px; font-weight:800;
    background:#1e2232; color:#e8e8ef; box-shadow: 0 6px 16px #0007, 0 0 0 1px #2a2f44 inset;
    transition: transform 70ms ease, background 70ms ease;
    touch-action: manipulation;
  }
  .dpad button:active { transform: translateY(1px) scale(0.98); background:#24293e; }
  .btn-wide {
    margin-top: 14px; padding:10px 16px; border-radius: 12px; font-weight:800;
    border:0; background:#23263a; color:#e8e8ef; box-shadow: 0 0 0 1px #2a2f44 inset;
  }

  /* Dialogs */
  .toast, .overlay {
    position: fixed; inset: auto 0 16px 0; display:flex; justify-content:center; pointer-events:none;
  }
  .toast .msg {
    background:#1d1f2a; color:#e8e8ef; padding:10px 14px; border-radius:10px; box-shadow:0 6px 24px #0009;
  }
  .overlay {
  position: fixed;
  inset: 0;
  background: #0008;
  align-items: center;
  justify-content: center;
  z-index: 100;         /* make sure it’s above everything */
  display: none;
  pointer-events: auto; /* ensure clicks go to overlay */
}

.overlay .card {
  pointer-events: auto; /* card & button can be clicked */
}
  .overlay {
    inset:0; background:#0008; align-items:center; z-index: 5;
  }
  .card {
    background:#171923; border-radius: 16px; padding: 18px; box-shadow: 0 18px 60px #000a, 0 0 0 1px #2a2f44 inset;
    width:min(92vw, 460px); text-align:center;
  }
  .card h2 { margin: 0 0 8px; }
  .card p { opacity: 0.9; }
  .card .row { display:flex; justify-content:space-between; gap:12px; margin-top:10px; }
  .card .row .btn { flex:1 1 auto; padding:10px; border-radius:12px; border:0; font-weight:800; }
  .btn-primary { background:#0f8f58; color:white; }
  .btn-secondary { background:#2a2f44; color:#e8e8ef; }
  .pulse { animation:pulse 800ms ease-in-out; }
  @keyframes pulse { 0%{transform:scale(1)} 50%{transform:scale(1.05)} 100%{transform:scale(1)} }
  @media (max-width: 640px) {
    :root { --cell: 28px; }
    .dpad { grid-template-columns: 56px 56px 56px; grid-template-rows: 56px 56px 56px; }
  }
</style>
</head>
<body>
  <div class="topbar">
    <div class="hearts" id="hearts"></div>
    <div class="score" id="score">Score: 250</div>
  </div>

  <div class="stage-wrap">
    <div class="grid" id="grid" aria-label="MazeSweeper grid"></div>
  </div>

  <div class="controls">
    <div class="dpad" aria-label="Move buttons">
      <div></div>
      <button id="btnUp"    aria-label="Up">▲</button>
      <div></div>
      <button id="btnLeft"  aria-label="Left">◀</button>
      <div></div>
      <button id="btnRight" aria-label="Right">▶</button>
      <div></div>
      <button id="btnDown"  aria-label="Down">▼</button>
      <div></div>
    </div>
    <button class="btn-wide" id="btnNew">New Game</button>
  </div>

  <div class="toast" id="toast" style="display:none;"><div class="msg" id="toastMsg"></div></div>
 <div class="overlay" id="overlay" style="display:none;">
    <div class="card">
      <h2 id="ovTitle">You Win!</h2>
      <p id="ovText"></p>
      <div class="row">
        <button class="btn btn-primary" id="btnAgain">Restart</button>
      </div>
    </div>
  </div>
<script>
(() => {
  const SIZE = 16;
  const START = {x:0, y:0}, GOAL = {x: SIZE-1, y: SIZE-1};
  const START_SCORE = 250;
  const START_LIVES = 3;
  const MINE_RATE = 0.4;

  let grid = [];
  let pathCells = new Set();
  let pos = {x:START.x, y:START.y};
  let lives = START_LIVES;
  let score = START_SCORE;
  let discovered = 0;

  const el = {
    grid: document.getElementById('grid'),
    hearts: document.getElementById('hearts'),
    score: document.getElementById('score'),
    toast: document.getElementById('toast'),
    toastMsg: document.getElementById('toastMsg'),
    overlay: document.getElementById('overlay'),
    ovTitle: document.getElementById('ovTitle'),
    ovText: document.getElementById('ovText'),
    btnAgain: document.getElementById('btnAgain'),
    btnNew: document.getElementById('btnNew'),
  };

  const key = (x,y)=>`${y},${x}`;
  const inBounds = (x,y)=> x>=0 && x<SIZE && y>=0 && y<SIZE;
  const shuffle = (arr)=>{ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]] } return arr; }

  function showToast(msg, ms=900){
    el.toastMsg.textContent = msg;
    el.toast.style.display = 'flex';
    el.toast.classList.add('pulse');
    setTimeout(()=>{ el.toast.style.display='none'; el.toast.classList.remove('pulse'); }, ms);
  }

  function showOverlay(title, text){
  el.ovTitle.textContent = title;
  el.ovText.textContent = text;
  el.overlay.style.display = 'flex';
  el.grid.style.pointerEvents = "none";   // disable grid
}

function hideOverlay(){
  el.overlay.style.display = 'none';
  el.grid.style.pointerEvents = "auto";   // re-enable grid
}

  function generateSinglePath(){
    const visited = Array.from({length:SIZE},()=>Array(SIZE).fill(false));
    const path = [];
    let solved = false;
    function dfs(x,y){
      if(solved) return true;
      visited[y][x] = true;
      path.push([x,y]);
      if(x===GOAL.x && y===GOAL.y){ solved = true; return true; }
      const dirs = shuffle([[1,0],[-1,0],[0,1],[0,-1]]);
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(inBounds(nx,ny) && !visited[ny][nx]){
          if(dfs(nx,ny)) return true;
        }
      }
      path.pop();
      return false;
    }
    dfs(START.x, START.y);
    return path;
  }

  function buildGrid(){
    const p = generateSinglePath();
    pathCells = new Set(p.map(([x,y])=>key(x,y)));

    grid = Array.from({length:SIZE},(_,y)=>
      Array.from({length:SIZE},(_,x)=>({ type:'wall', number:0, revealed:false, visited:false, steppedOn:false }))
    );

    for(const [x,y] of p) grid[y][x].type = 'clear';
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        if(!pathCells.has(key(x,y))){
          grid[y][x].type = (Math.random() < MINE_RATE) ? 'mine' : 'wall';
        }
      }
    }

    const dirs8 = [-1,0,1].flatMap(dy => [-1,0,1].map(dx=>[dx,dy]))
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        let c=0;
        for(const [dx,dy] of dirs8){
          const nx=x+dx, ny=y+dy;
          if(inBounds(nx,ny) && grid[ny][nx].type==='mine') c++;
        }
        grid[y][x].number = c;
      }
    }
  }

  function renderGrid(){
    el.grid.innerHTML = '';
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const c = document.createElement('div');
        c.className = 'cell unrevealed';
        c.dataset.x = x; c.dataset.y = y;
        el.grid.appendChild(c);
      }
    }
    grid[START.y][START.x].revealed = true;
    grid[START.y][START.x].visited = true;
    updateCell(START.x, START.y, {current:true});
    updateHUD();
  }

  function updateHUD(){
    el.hearts.innerHTML = '';
    for(let i=0;i<START_LIVES;i++){
      const h = document.createElement('div');
      h.className = 'heart' + (i < lives ? '' : ' empty');
      el.hearts.appendChild(h);
    }
    el.score.textContent = `Score: ${score}`;
  }

  function updateCell(x,y,{current=false}={}){
    const idx = y*SIZE + x;
    const node = el.grid.children[idx];
    const cell = grid[y][x];

    node.className = 'cell';
    if(!cell.revealed){
      node.classList.add('unrevealed');
      node.textContent='';
    } else {
      node.classList.add('revealed');
      const n = cell.number;
      node.textContent = n>0 ? String(n) : '';
      if(n>=1 && n<=8) node.classList.add('n'+n);

      if(cell.visited && !current) node.classList.add('trail');

      // Bomb color logic
      if(cell.type==='mine'){
        if(current){
          node.classList.add('bomb-current'); // purple
        } else if(cell.steppedOn){
          node.classList.add('bomb-stepped'); // red
        }
      }
    }
    if(current && cell.type!=='mine') node.classList.add('current');
  }

  function setCurrent(x,y){
    // mark old bomb if leaving it
    const prev = grid[pos.y][pos.x];
    if(prev.type==='mine' && prev.revealed){
      prev.steppedOn = true;
      updateCell(pos.x,pos.y,{current:false});
    } else {
      updateCell(pos.x,pos.y,{current:false});
    }

    pos = {x,y};
    grid[y][x].visited = true;
    updateCell(x,y, {current:true});
  }

  function gainDiscovery(x,y, deductScore = true){
    const cell = grid[y][x];
    if(!cell.revealed){
      cell.revealed = true;
      discovered++;
      if (deductScore) score = Math.max(0, score - 1);
      updateCell(x,y);
      updateHUD();
    }
  }

  function revealOrthogonalNeighbors(x,y, deductScoreForNeighbors = true){
    const orth = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of orth){
      const nx = x+dx, ny = y+dy;
      if(!inBounds(nx,ny)) continue;
      gainDiscovery(nx, ny, deductScoreForNeighbors);
    }
  }

  function tryMove(dx,dy){
    const nx = pos.x + dx, ny = pos.y + dy;
    if(!inBounds(nx,ny)) { showToast("Edge of map"); return; }
    const dest = grid[ny][nx];
    if(dest.type === 'wall'){ cellFlash(nx,ny); showToast("Wall"); return; }

    gainDiscovery(nx,ny,true);

    if(dest.type === 'mine'){
      lives--; score = Math.max(0, score - 75);
      updateHUD(); showToast("💥 -1 life, -75 score");
      setCurrent(nx,ny);
      revealOrthogonalNeighbors(nx,ny,true);
      if(lives <= 0){ gameOver(false); return; }
      return;
    }

    setCurrent(nx,ny);
    revealOrthogonalNeighbors(nx,ny,true);
    if(nx === GOAL.x && ny === GOAL.y) gameOver(true);
  }

  function cellFlash(x,y){
    const node = el.grid.children[y*SIZE+x];
    node.style.outline = '2px solid #ffca3a';
    setTimeout(()=> node.style.outline = '', 140);
  }

  function gameOver(win){
    const msg = win
      ? `Reached the goal with score ${score}, ${discovered} discoveries, ${lives} ❤ left.`
      : `You ran out of lives. Final score ${score}, discoveries ${discovered}.`;
    showOverlay(win? "You Win!" : "Game Over", msg);
  }

  el.grid.addEventListener('click', (e)=>{
    const t = e.target.closest('.cell'); if(!t) return;
    const x = +t.dataset.x, y = +t.dataset.y;
    const dx = x - pos.x, dy = y - pos.y;
    if(Math.abs(dx) + Math.abs(dy) !== 1){ showToast("Tap an adjacent cell"); return; }
    tryMove(Math.sign(dx), Math.sign(dy));
  });

  document.getElementById('btnUp').addEventListener('click', ()=>tryMove(0,-1));
  document.getElementById('btnDown').addEventListener('click', ()=>tryMove(0, 1));
  document.getElementById('btnLeft').addEventListener('click', ()=>tryMove(-1,0));
  document.getElementById('btnRight').addEventListener('click', ()=>tryMove(1, 0));
  el.btnNew.addEventListener('click', newGame);
  el.btnAgain.addEventListener('click', ()=>{ hideOverlay(); newGame(); });

  window.addEventListener('keydown', (e)=>{
    if(el.overlay.style.display !== 'none') return;
    if(e.key==='ArrowUp'){ e.preventDefault(); tryMove(0,-1); }
    if(e.key==='ArrowDown'){ e.preventDefault(); tryMove(0, 1); }
    if(e.key==='ArrowLeft'){ e.preventDefault(); tryMove(-1,0); }
    if(e.key==='ArrowRight'){ e.preventDefault(); tryMove(1, 0); }
  });

  function newGame(){
    hideOverlay();
    lives = START_LIVES; score = START_SCORE; discovered = 0;
    pos = {x:START.x, y:START.y};
    buildGrid(); renderGrid();
  }

  newGame();
})();
</script>
</body>
</html>